# Учебная виртуальная машина (УВМ) — Этап 1

# 1. Назначение

Этап 1 проекта посвящён созданию **ассемблера** для учебной виртуальной машины (УВМ).
Ассемблер переводит текстовую программу в **промежуточное представление (A/B/C)** и далее в **5‑байтный машинный код**, строго соответствующий спецификации УВМ.

Инструмент реализован в Python в виде CLI-приложения.

---

# 2. Язык ассемблера

Ассемблер использует человекочитаемый синтаксис, похожий на высокоуровневые языки.

## Формат инструкции

```
МНЕМОНИКА аргумент1, аргумент2
```

## Допустимые аргументы

* десятичные числа: `123`
* шестнадцатеричные числа: `0xFF`
* константы, объявленные через `.set`

## Комментарии

* `# комментарий`
* `; комментарий`
* inline: `LOAD_CONST 10, 20  # пример`

## Поддерживаемые инструкции

| Mnemonic                 | Описание                      | A  | Формат |
| ------------------------ | ----------------------------- | -- | ------ |
| `LOAD_CONST value, addr` | загрузить константу в память  | 45 | SHORT  |
| `READ b_addr, c_addr`    | чтение косвенным адресованием | 55 | FULL   |
| `WRITE b_addr, c_addr`   | запись значения в память      | 14 | FULL   |
| `BITREV b_addr, c_addr`  | унарная операция bitreverse() | 34 | FULL   |

## Директивы

```
.set NAME = VALUE
```

Пример:

```
.set X = 100
LOAD_CONST X, 500
```

---

# 3. Форматы команд УВМ

Каждая команда занимает **5 байт (40 бит)**.

## Формат SHORT (LOAD_CONST)

| Поле | Биты  | Размер |
| ---- | ----- | ------ |
| A    | 0–5   | 6      |
| B    | 6–21  | 16     |
| C    | 22–38 | 17     |

Кодирование:

```
value = A | (B << 6) | (C << 22)
```

## Формат FULL (READ, WRITE, BITREV)

| Поле | Биты  | Размер |
| ---- | ----- | ------ |
| A    | 0–5   | 6      |
| B    | 6–22  | 17     |
| C    | 23–39 | 17     |

Кодирование:

```
value = A | (B << 6) | (C << 23)
```

---

# 4. Использование ассемблера

Ассемблер — это Python CLI-приложение.

## Запуск

```
python uvm_assembler.py input.asm output.bin [--test]
```

## Аргументы

* `input.asm` — исходная текстовая программа
* `output.bin` — бинарный файл результата
* `--test` — вывод промежуточного представления (A/B/C и 5 байт)

---

# 5. Пример программы (`test1.asm`)

```
# Test program from specification
LOAD_CONST 146, 456
READ 679, 835
WRITE 716, 603
BITREV 313, 398
```

---

# 6. Пример запуска

```
python uvm_assembler.py test.asm out.bin --test
```

## Пример выводимых данных

```
Assembled program (intermediate representation):
Line   2: LOAD_CONST   A=45, B=146, C=456 -> 0xAD, 0x24, 0x00, 0x72, 0x00
Line   3: READ         A=55, B=679, C=835 -> 0xF7, 0xA9, 0x80, 0xA1, 0x01
Line   4: WRITE        A=14, B=716, C=603 -> 0x0E, 0xB3, 0x80, 0x2D, 0x01
Line   5: BITREV       A=34, B=313, C=398 -> 0x62, 0x4E, 0x00, 0xC7, 0x00
```

Все байты **полностью совпадают** с эталоном спецификации УВМ.

---

# 7. Результаты этапа

На этапе 1 выполнено:

* разработан человекочитаемый язык ассемблера;
* реализован корректный разбор команд и директив `.set`;
* создано промежуточное представление (A/B/C);
* реализовано точное побитовое кодирование команд УВМ;
* создан бинарный файл `output.bin`;
* реализован режим `--test` для отображения IR;
* подтверждено совпадение байтов с официальной спецификацией.

